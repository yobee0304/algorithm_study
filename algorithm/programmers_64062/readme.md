# 징검다리 건너기
# 1. 문제
https://programmers.co.kr/learn/courses/30/lessons/64062

# 2. 유형
* Binary-search

# 3. 풀이
* 돌의 크기가 최대 200,000개이기 때문에 O(N^2)의 탐색은 시간 초과가 난다.
* 따라서, 보다 빠른 O(NlogN) 탐색인 '이분탐색'을 활용하면 보다 빠르게 문제를 해결할 수 있다.
* 돌의 높이가 200,000,000이므로, 징검다리를 건널 수 있는 친구들의 수는 1이상 200,000,000이하다.
* 따라서 주어진 범위 안에서 이분탐색을 진행하면 기대값을 구할 수 있다.
  * 주어진 범위의 중앙값 mid 구한다.
```python
mid = (left + right) // 2
```
  * 모든 돌의 높이와 구한 mid의 차를 이용하여, mid만큼의 친구가 징검다리를 건널 수 있는지 확인한다.
```python
for i in range(len(stones_cpy)):
    stones_cpy[i] -= mid
    if stones_cpy[i] <= 0:
        cnt += 1
        else:
    cnt = 0

    if cnt >= k:
        check = False
        break
```
  * 현재 징검다리를 건널 수 있으면 더 많은 친구수로 범위를 넓히고, 그렇지 않으면 적은 친구수로 범위를 줄인다.* 
```python
if check is True:
    left = mid + 1
elif check is False:
    right = mid - 1
```

# 4. 후기
처음에는 다음과 같이 문제 풀이를 진행했다.
* 현재 돌에서 갈 수 있는 돌들 중에서 가장 높은 돌로 이동한다.
* 이런 방식으로 모든 돌을 이동했다고 가정 했을 때, 지나왔던 돌들 중에서 가장 낮은 돌의 높이가 건널 수 있는 친구수의 최대값이 된다.
* 하지만 이런 방식으로 풀었을 때, 다음과 같은 문제점이 발생했다.
  * 현재 돌에서 갈 수 있는 돌의 범위 또한, 최대값이 돌의 개수와 같다.
  * 따라서 최악의 경우는 O(N^2)이 되므로 시간초과가 발생한다.

평소에 이분탐색은 단순히 배열안에서 값을 탐색할때만 사용했는데, 이러한 방식으로도 활용할 수 있다는 것을 배운것 같다.

기존의 방식도 더 빠르게 할 수 있는 방법을 고민해 봐야겠다.
