# 최종 순위

# 1. 문제
https://www.acmicpc.net/problem/3665

# 2. 유형
* 위상 정렬(Topology Sort)

# 3. 풀이
  * 우선 순위
    * 주어진 우선 순위가 1, 2, 3인 경우를 그래프로 옮겨 보면 (1->2), (1->3), (2->3)의 간선이 생성된다.
    * 즉, 자신보다 우선 순위가 낮은 모든 노드로 간선이 생성된다고 생각하면 쉽다.
    * 해당 문제는 모든 우선 순위를 주어진 후, 변경된 우선 순위를 다시 반영해주면 된다.
```python
# 변경된 우선순위 반영
for i in range(m):
    node1, node2 = changes[i]
    if node2 in graph[node1]:
        node1, node2 = node2, node1
    graph[node1].append(node2)
    graph[node2].remove(node1)
```

  * 진입 차수
    * 각 노드의 진입 차수를 저장하는 배열이 필요하다.
    * 진입 차수가 0이 되면 선택할 수 있는 노드가 된다.
    * (1->2), (1->3), (2->3)의 경우, 각 노드의 진입 차수 배열은 [0, 1, 2]가 된다. 이때는 진입 차수가 0인 1이 가장 먼저 선택된다.
    
```python
# 진입 차수 배열 생성
for i in range(1, n+1):
    for j in range(len(graph[i])):
        topology[graph[i][j]] += 1
        
# 현재 진입할 수 있는 노드를 선택에서 큐에 넣는다.
for i in range(1, n+1):
    if topology[i] == 0:
        q.append(i)
```

  * 선택된 노드가 가리키는 노드의 모든 진입 차수를 1씩 줄인다. 
  * 이때, 줄어든 진입 차수들 중에 0이 되는 노드를 다시 선택하고 이 과정을 반복하면 된다.
    
```python
# 큐가 빌 때까지 반복
while q:
    top = q[0]
    q.pop(0)
    ans.append(top)

    target = graph[top]
    # 선택된 노드가 가리키는 다른 노드들의 진입 차수를 줄인다
    for t in target:
        topology[t] -= 1
        # 해당 노드를 선택할 수 있으면 선택
        if topology[t] == 0:
            q.append(t)
```
  * 우선순위가 결정되지 않는 경우
    * 모든 노드의 순위가 결정되지 않았는데, **더 이상 선택할 노드가 존재하지 않는 경우** 이다.
    * 이 경우, 정답이 들어있는 리스트 ans의 길이와 모든 노드의 개수를 비교해보면 판단할 수 있다.
    
# 4. 후기

단순히 등수를 서로 변경하면 해결하는 문제로 접근했으나 이상함을 느꼈다.

주어진 우선순위를 그래프화하여 위상 정렬을 활용할 수 있다는 점이 가장 크게 놓친 부분이라고 생각한다.

등수를 결정할 수 없는 경우를 발견하는 것도 위상 정렬을 활용하니 자연스럽게 해결되었다.
