# 트리 트리오 중간값

# 1. 문제
https://programmers.co.kr/learn/courses/30/lessons/68937

# 2. 유형
* 그래프(Graph)
* 그래프의 지름

# 3. 풀이
## 개요
* 중간값을 구하기 위해서는 '그래프의 지름'값이 필요합니다.
  * 그래프의 지름이란, 그래프를 이루고 있는 특정 노드를 2개 정할 때 가장 긴 길이를 말합니다.
* 그래프의 지름이 2개 이상이라면, 중간값은 **그래프의 지름**이 됩니다.
* 그래프의 지름이 1개라면, 중간값은 **그래프의 지름 - 1**이 됩니다.
* 따라서, 그래프의 지름을 먼저 구하고 그 지름이 몇 개인지를 확인하는 작업이 필요합니다.

## 풀이
* 먼저 임의의 점을 기준으로 하여 탐색 알고리즘을 통해 가장 먼 위치의 점을 찾습니다.
  * 이 때 찾은 점은 그래프 지름의 한 점이 됩니다.
```python
q = Queue()
# 임의의 점을 기준으로 탐색을 시작
# 여기는 1부터 시작(어느 점을 기준으로 해도 상관 X)
q.put(1)
# 탐색은 BFS알고리즘을 통해 진행
rad, endPoint = bfs(graph, q, n)
```

* 구한 지름의 끝점으로 반대쪽 점을 같은 탐색 방식으로 구한다.
```python
q = Queue()
# 구한 점들 중에서는 아무 점이나 상관 없다!
q.put(endPoint[0])
# 지름의 다른 점 구하기
rad, endPoint = bfs(graph, q, n)

# 만약 지름이 2개 이상 있다면, 중간값을 구할 수 있으므로
if len(endPoint) > 1:
    return rad
```

* 만약 반대쪽의 점이 1개인 경우, 그 점을 기준으로 다른 지름이 없는지 마지막으로 확인해야 한다.
```python
q = Queue()
q.put(endPoint[0])
rad, endPoint = bfs(graph, q, n)

# 지름이 2개 이상이라면, 중앙값은 지름의 길이
if len(endPoint) > 1:
    return rad
# 지름이 1개라면, 중앙값은 (지름의 길이 - 1)
else:
    return rad - 1
```

# 4. 후기

먼저 탐색을 DFS와 BFS 2가지 모두로 진행해 봤지만, BFS는 시간 초과 / DFS는 런타임 에러가 발생했다(이유는 아직도 정확이 모르겠다).

따라서, 개선의 여지가 있는 BFS를 선택하여 풀었고, 다음과 같은 부분을 개선하여 최적화를 진행했다.

1. BFS를 진행할 때 큐 형태를 사용했는데, 처음에는 list를 활용하여 구현했지만 push와 pop부분에서 많은 시간이 소요되었다.

이 부분을 개선하기 위해 list대신 queue를 사용하였다.(deque를 사용해도 무방했다)

2. BFS를 진행할 때, 중복 노드 검사하는 방식

원래는 방문한 노드를 list에 넣어두고, 현재 진행할 노드가 list에 있는지 확인하는 식으로 구현했다.

하지만, 단순히 list를 확인하는 것 만으로도 O(n)이 걸리므로 굉장한 시간적 손해가 발생했다.

따라서, 미리 노드 개수만큼 list를 선언하고 방문한 노드의 list값을 False에서 True로 바꿔주는 식으로 구현했다.

단순히 코드 전체를 수정하는 것이 아니라, 자료 구조나 탐색 방식을 개선해도 굉장히 큰 효과가 있다는 것을 새삼 깨닫게 되었다.

다음부터는, 처음 코드를 짤 때부터 최적화된 코드를 생각해 내기 위해 노력해야겠다.
