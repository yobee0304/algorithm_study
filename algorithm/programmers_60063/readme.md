# 블록 이동하기
## 1. 문제
https://programmers.co.kr/learn/courses/30/lessons/60063

## 2. 유형
* BFS

## 3. 풀이
일반적인 탐색 문제와는 달리, 현재 드론의 위치가 두 칸을 차지하고 있다.

또한 드론이 상하좌우로 움직이는 것 뿐만 아니라, 트론의 한 점을 기준으로 시계 혹은 반시계 회전이 가능하다.

따라서, 현재 위치에서 드론이 1초 동안 할 수 있는 행위는

1. 오른쪽으로 이동
2. 왼쪽으로 이동
3. 위로 이동
4. 아래로 이동
5. 드론이 차지하는 첫 번째 칸을 축으로, 시계 회전
6. 드론이 차지하는 첫 번째 칸을 축으로, 반시계 회전
7. 드론이 차지하는 두 번째 칸을 축으로, 시계 회전
8. 드론이 차지하는 두 번째 칸을 축으로, 반시계 회전

총 8가지가 가능하다. (단, 회전하는 방향의 대각선이 막혀있지 않아야 하므로 확인해야한다)

따라서 현재 드론들이 할 수 있는 경우의 수를 모두 확인하며 BFS 탐색을 진행한다.

단, 드론이 되돌아가는 경우를 방지하기 위해서 visited 리스트를 하나 선언하여 방문한 위치를 저장하였다.

```python
# dron은 2칸을 차지하므로 [[?,?],[?,?]] 형태
if dron in visited:
    continue
else:
    # visited에 dron을 그대로 넣는다
    visited.append(dron)
```
## 4. 후기
일반적인 탐색과는 다르게 드론의 두 점을 모두 감안해야 하는 점 때문에, 처음에는 탐색으로 접근하기 힘들었다.

또한 처음에 DFS로 문제를 풀었을때는 visited를 확인하는 부분 때문에 시간초과로 오류가 났었다.

BFS와 DFS의 visited 차이점은
1. BFS : 현재 드론의 위치만 통채로 visited에 넣는다
2. DFS : 현재 드론의 위치화 함께, 현재 시간까지 visited에 넣는다.
2번의 경우, 같은 위치라도 시간이 더 짧다면 갱신을 해줘야 했기 때문에 아마 이 부분에서 시간이 낭비된 것 같다.

다시 돌아봤을때는 두칸을 같이 움직이고, 회전하는 경우까지 감안해서 다른 탐색 문제와 비슷하게 접근하면 되는 문제였던 것 같다.

보통 탐색 문제에 접근할 때 바로 DFS로 접근하는 습관이 있는데, BFS와 DFS의 차이를 인식하고 어떤 것이 더 나은지 생각해본 뒤 문제를 푸는 습관이 필요할 것 같다.
